import random
import os

# 0 黑桃 1 红桃 2 方片 3 草花
# 牌的id: 0-51

initMoney = 1000    # 初始钱数
bigBlind = 20       # 大盲注
totalPlayer = 5     # 玩家人数
button = 0          # 庄家位置


# 将牌的id转为颜色
def id2color(card):
    return card % 4

# 将牌的id转为数字
def id2num(card):
    return card // 4


'''
牌面level编号
    皇家同花顺：10
    同花顺    ：9
    四条      ：8
    葫芦      ：7
    同花      ：6
    顺子      ：5
    三条      ：4
    两对      ：3
    一对      ：2
    高牌      ：1
'''

class Hand:


    def __init__(self, cards):
        cards = cards[:]
        self.level = 0              # 盘面的等级
        self.cnt_num = [0] * 13     # 每种数字的个数
        self.cnt_color = [0] * 4    # 每种颜色的个数
        self.cnt_num_eachcolor = [[0 for col in range(13)] for row in range(4)]  # 记录每种花色的牌
        self.maxnum = -1            # 最大等级五牌最大数字
        self.single = []            # 单牌
        self.pair = []              # 对子
        self.tripple = []           # 三条
        for x in cards:
            self.cnt_num[id2num(x)] += 1
            self.cnt_color[id2color(x)] += 1
            self.cnt_num_eachcolor[id2color(x)][id2num(x)] += 1
        for i in range(12, -1, -1):
            if self.cnt_num[i] == 1:
                self.single.append(i)
            elif self.cnt_num[i] == 2:
                self.pair.append(i)
            elif self.cnt_num[i] == 3:
                self.tripple.append(i)
        self.single.sort(reverse=True)
        self.pair.sort(reverse=True)
        self.tripple.sort(reverse=True)
        # 判断皇家同花顺
        for i in range(4):
            if self.cnt_num_eachcolor[i][8:13].count(1) == 5:
                self.level = 10
                return

        # 判断同花顺
        for i in range(4):
            for j in range(7, -1, -1):       # 从7开始，因为8，9，10，11，12是同花顺
                if self.cnt_num_eachcolor[i][j:j+5].count(1) == 5:
                    self.level = 9
                    self.maxnum = j + 4
                    return

        # 判断四条
        for i in range(12, -1, -1):
            if self.cnt_num[i] == 4:
                self.maxnum = i
                self.level = 8
                return

        # 判断葫芦
        tripple = self.cnt_num.count(3)
        if tripple > 1:
            self.level = 7
            return
        elif tripple > 0:
            if self.cnt_num.count(2) > 0:
                self.level = 7
                return

        # 判断同花
        for i in range(4):
            if self.cnt_color[i] >=5:
                if(max(self.cnt_num_eachcolor[i]) > self.maxnum):
                    self.maxnum = max(self.cnt_num_eachcolor[i])
                self.level = 6
        if self.level == 6:
            return
        # 判断顺子
        for i in range(8, -1, -1):
            flag = 1
            for j in range(i, i + 5):
                if self.cnt_num[j] == 0:
                    flag = 0
                    break
            if flag == 1:
                self.maxnum = i + 4
                self.level = 5
                return

        # 判断三条
        for i in range(12, -1, -1):
            if self.cnt_num[i] == 3:
                self.maxnum = i
                self.level = 4
                return

        # 判断两对
        if self.cnt_num.count(2) > 1:
            self.level = 3
            return

        # 判断一对
        for i in range(12, -1, -1):
            if self.cnt_num[i] == 2:
                self.maxnum = i
                self.level = 2
                return

        # 高牌
        if self.cnt_num.count(1) == 7:
            self.level = 1
            return

        self.level = -1

    def __str__(self):
        return 'level = %s' % self.level


def cmp(x,y):  # x < y return 1
    if x > y: return -1
    elif x == y: return 0
    else: return 1


def judge_two(cards0, cards1):      # 比较两手牌的大小，cards0和cards1都是7元组，若cards0大则返回-1，一样大返回0，否则返回1
    hand0 = Hand(cards0)
    hand1 = Hand(cards1)
    if hand0.level > hand1.level:
        return 0
    elif hand0.level < hand1.level:
        return 1
    else:       # 同级别牌面比较  皇家同花顺一定不会同时出现
        if hand0.level in [5, 6, 9]: # 只用比最大
            return cmp(hand0.maxnum, hand1.maxnum)
        elif hand0.level in [1, 2, 4]: # 先比最大，再比单牌
            t = cmp(hand0.maxnum, hand1.maxnum)
            if t == 1: return 1
            elif t == -1: return -1
            else:
                if hand0.single < hand1.single:
                    return 1
                elif hand0.single == hand1.single:
                    return 0
                else:
                    return -1
        elif hand0.level == 8:  # 先比最大，再比单牌/对子
            t = cmp(hand0.maxnum, hand1.maxnum)
            if t == 1:
                return 1
            elif t == -1:
                return -1
            else:
                pair_single0 = hand0.pair + hand0.pair + hand0.single
                pair_single0.sort()
                pair_single1 = hand1.pair + hand1.pair + hand1.single
                pair_single1.sort()
                if pair_single0 < pair_single1:
                    return 1
                elif pair_single0 == pair_single1:
                    return 0
                else:
                    return -1
        elif hand0.level == 3:
            if cmp(hand0.pair[0], hand1.pair[0]) != 0:
                return cmp(hand0.pair[0], hand1.pair[0])
            elif cmp(hand0.pair[1], hand1.pair[1]) != 0:
                return cmp(hand0.pair[1], hand1.pair[1])
            else:
                hand0.pair = hand0.pair[2:]
                hand1.pair = hand1.pair[2:]
                tmp0 = hand0.pair + hand0.pair + hand0.single
                tmp1 = hand1.pair + hand1.pair + hand1.single
                if tmp0 < tmp1:
                    return 1
                elif tmp0 == tmp1:
                    return 0
                else:
                    return -1

        elif hand0.level == 7:
            if cmp(hand0.tripple[0], hand1.tripple[0]) != 0:
                return cmp(hand0.tripple[0], hand1.tripple[0])
            else:
                tmp0 = hand0.pair
                tmp1 = hand1.pair
                if len(hand0.tripple) > 1:
                    tmp0.append(hand0.tripple[1])
                if len(hand1.tripple) > 1:
                    tmp1.append(hand1.tripple[1])
                if tmp0 < tmp1:
                    return 1
                elif tmp0 == tmp1:
                    return 0
                else:
                    return -1
        else:
            pass
            # assert 0





class Player:
    active = True           # 玩家是否已弃牌
    money = initMoney       # 玩家持有的钱数
    bet = 0                 # 玩家在本轮下注
    cards = []              # 玩家手牌
    allin = 0               # 玩家是否已allin
    totalbet = 0            # 玩家在本局的总下注


    def raisebet(self, amount):
        self.money -= amount
        self.bet += amount
        assert self.money > 0


    def allinbet(self):        # 玩家 allin
        self.bet += self.money
        self.allin = 1
        self.money = 0

    def getcards(self):
        return self.cards + state.sharedcards

    def __str__(self):
        return 'player: active = %s, money = %s, bet = %s, allin = %s' % (self.active, self.money, self.bet, self.allin)



player = []                 # 玩家
for i in range(totalPlayer):
    player.append(Player())


class State:
    currpos = 0             # 当前轮到的玩家
    playernum = totalPlayer # 未弃牌的玩家总数
    moneypot = 0            # 池中总钱数
    minbet = bigBlind       # 当前跟注的最小值
    sharedcards = []        # 已亮出的公共牌
    turnNum = 0             # 轮次  0：pre-lop     1: flop     2: turn     3: river
    last_raised = bigBlind         # 上一次的加注额
    def __str__(self):
        return 'state: currpos = %s, playernum = %s, moneypot = %s, \n minbet = %s, last_raised = %s' \
               % (self.currpos, self.playernum, self.moneypot, self.minbet, self.last_raised)


state = State()           # 游戏状态


def round_over():
    if state.playernum == 1:        #TODO 游戏结束  只剩1人?
        for i in range(totalPlayer):
            if player[i].active == True:
                print('Only Winner: player %s' % i)
        return 1
    for i in range(totalPlayer):
        if player[i].active is True and player[i].allin == 0:
            break
    else:
        return 1  # 所有人allin
    for i in range(totalPlayer):
        if player[i].active is True and (player[i].bet != state.minbet and player[i].allin == 0):
            return 0  # 有某个未退出的玩家下注未达最小值且未allin，回合尚未结束
    if state.turnNum != 0 and state.minbet == 0:
        return 0      # 仍在看牌，尚未有人下注
    return 1          # 回合结束


def nextpos(pos):
    return (pos + 1) % totalPlayer

def illegalmove(playerid):              # player进行非法行动的处理
    # TODO  send infomation to the player: illegal decision!
    player[playerid].active = False
    state.playernum -= 1
    state.currpos = nextpos(state.currpos)
    print('player %s illegal move' % playerid)

class Decision:
    giveup = 0    # 弃牌
    allin = 0     # allin
    check = 0     # 看牌
    callbet = 0   # 跟注
    raisebet = 0  # 加注
    amount = 0    # 加注到amount
    def clear(self):
        self.giveup = self.allin = self.check = self.callbet = self.raisebet = self.amount = 0

decision = Decision()

def findwinner():       # 从active的玩家中找到一个赢家
    winpos = -1
    for pos in range(totalPlayer):
        if player[pos].active == 0:
            continue
        if winpos == -1:
            winpos = pos
        else:
            t = judge_two(player[winpos].getcards(), player[pos].getcards())
            if t == 1:
                winpos = pos
    return winpos


def play_round(round):
    checkflag = 0  # 记录是否可以看牌（即尚未有人下注）
    while True:
        if round_over() == 1:  # TODO 除了一人以外其他人都弃牌，但此人无足够的钱下注来继续游戏 如何处理
            break
        state.currpos = nextpos(state.currpos)
        if player[state.currpos].active == False:
            continue
        if player[state.currpos].allin == 1:
            continue

        # TODO   send state and player info to player[state.currpos]
        # TODO   run player AI
        naive_ai(state.currpos)
        # TODO   receive decision from player， decision = (give-up, allin, check, callbet, raisebet, amount)

        # pre-flop轮，不可能check，此位会被忽略
        if decision.giveup == 1:  # 玩家弃牌
            player[state.currpos].active = False
            state.playernum -= 1
            print("## player %s giveup" % state.currpos)
        elif round != 0 and decision.check == 1:  # 玩家过牌
            if checkflag == 1:
                illegalmove(state.currpos)
                continue
            print("## player %s check" % state.currpos)
            continue
        elif decision.allin == 1:  # 玩家allin
            state.moneypot += player[state.currpos].money
            player[state.currpos].allinbet()
            if player[state.currpos].bet > state.minbet:  # allin 加注
                state.last_raised = player[state.currpos].bet - state.minbet
                state.minbet = player[state.currpos].bet
            checkflag = 1
            print("## player %s allin: %s" % (state.currpos, player[state.currpos].money))

        elif decision.callbet == 1:  # 玩家跟注
            delta = state.minbet - player[state.currpos].bet
            assert delta > 0
            if delta >= player[state.currpos].money or delta < 0:  # 跟注时所有钱押入，这种情况属于allin
                illegalmove(state.currpos)
                continue
            player[state.currpos].raisebet(delta)
            state.moneypot += delta
            checkflag = 1
            print("## player %s callbet: %s" % (state.currpos, delta))

        elif decision.raisebet == 1:  # 玩家加注
            assert decision.amount >= state.minbet
            if decision.amount - state.minbet < state.last_raised:  # 加注量至少和上一次一致
                illegalmove(state.currpos)
                continue
            state.last_raised = decision.amount - state.minbet
            state.minbet = decision.amount
            delta = decision.amount - player[state.currpos].bet
            if delta >= player[state.currpos].money or delta < 0:  # 跟注时所有钱押入，这种情况属于allin
                illegalmove(state.currpos)
                continue
            player[state.currpos].raisebet(delta)
            state.moneypot += delta
            checkflag = 1
            print("## player %s raisebet: %s" % (state.currpos, delta))

        else:  # 不合法行动
            illegalmove(state.currpos)
            continue
        print(state)
        print(player[state.currpos])
        # print('round summary: player bet = %s, player money = %s' % (player[state.currpos].bet, player[state.currpos].money))
        # print('state minbet = %s, active player = %s' % (state.minbet, state.playernum))


def naive_ai(id):
    delta = state.minbet - player[id].bet
    decision.clear()
    if delta <= 0:  # 还在看牌期，之前无人下注
        if player[id].money < bigBlind:
            flag = random.randint(1, 5)
            if flag == 1:
                decision.giveup = 1
            else:
                decision.allin = 1
        elif player[id].money == bigBlind:
            decision.allin = 1
        else:
            decision.raisebet = 1
            decision.amount = bigBlind
    elif player[id].money <= delta:      # 手中的钱不够补全或正好补全
        flag = random.randint(1, 5)
        if flag == 1:
            decision.giveup = 1
        else:
            decision.allin = 1

    else:
        # t = random.randint(1, 5)
        if player[id].money > delta + state.last_raised:
            flag = random.randint(1, 2)
            if flag == 2:
                decision.callbet = 1
            else:
                decision.raisebet = 1
                decision.amount = random.randint(state.minbet + state.last_raised, player[id].bet+ player[id].money - 1)

        else:
            decision.callbet = 1




# main routine

'''
向玩家AI发送的信息：state, player
从玩家AI接受的信息：decision = (give-up, allin, check, callbet, raisebet, amount)
'''



# 洗牌，准备牌堆
cardHeap = list(range(0,52))
random.shuffle(cardHeap)

# pre-flop begin
print('$$$ pre-flop begin')
# 小盲注、大盲注
state.currpos = nextpos(button)
player[state.currpos].raisebet(bigBlind // 2)
state.moneypot += bigBlind // 2
print("## player %s smallBlind: %s" % (state.currpos, bigBlind // 2))
print(state)
print(player[state.currpos])

state.currpos = nextpos(state.currpos)
player[state.currpos].raisebet(bigBlind)
state.moneypot += bigBlind
print(state)
print(player[state.currpos])
print("## player %s bigBlind: %s" % (state.currpos, bigBlind))

play_round(0)

# pre-flop ended
for i in range(totalPlayer):
    if player[i].active == False:
        continue
    player[i].totalbet += player[i].bet
    player[i].bet = 0
state.sharedcards = cardHeap[0:3]

# flop begin
print('$$$ flop begin')
#TODO 如果所有人一直看牌（check）会怎么样 ?

state.turnNum = 1
state.currpos = button
state.minbet = 0
state.last_raised = bigBlind

play_round(1)


# flop ended
for i in range(totalPlayer):
    if player[i].active == False:
        continue
    player[i].totalbet += player[i].bet
    player[i].bet = 0
state.sharedcards = cardHeap[0:4]

# turn begin
print('$$$ turn begin')
#TODO 如果所有人一直看牌（check）会怎么样 ?

state.turnNum = 2
state.currpos = button
state.minbet = 0
state.last_raised = bigBlind

play_round(2)

# turn ended
for i in range(totalPlayer):
    if player[i].active == False:
        continue
    player[i].totalbet += player[i].bet
    player[i].bet = 0
state.sharedcards = cardHeap[0:5]

# river begin
print('$$$ river begin')
#TODO 如果所有人一直看牌（check）会怎么样 ?

state.turnNum = 3
state.currpos = button
state.minbet = 0
state.last_raised = bigBlind

play_round(3)

# river ended
for i in range(totalPlayer):
    if player[i].active == False:
        continue
    player[i].totalbet += player[i].bet
    player[i].bet = 0


print("game ended")

# game over, 开始分配彩池

totalmoney = state.moneypot


while state.playernum > 0:
    pos = findwinner()
    t = player[pos].totalbet
    sum = 0
    for i in range(totalPlayer):
        sum += min(t, player[i].totalbet)
        player[i].totalbet -= min(t, player[i].totalbet)
        if player[i].totalbet == 0:
            player[pos].active = False
            state.playernum -= 1
    player[pos].money += sum

print('final state:')
for i in range(totalPlayer):
    print("player %s have money %s" % (i, player[i].money))

# main routine ended


'''
# 测试：计算牌面 level

A = [0] * 7
for i in range(7):
    A[i] = random.randint(0, 51)
print(A)
B = [[0 for col in range(2)] for row in range(7)]
for i in range(7):
    B[i][0] = id2color(A[i])
    B[i][1] = id2num(A[i])
B.sort(key=lambda f: f[1])
for i in B:
    print("color = %s, num = %s" % (i[0], i[1]))
a = Hand(A)
print(a.level)
'''

'''
while True:
    A = [0] * 7
    for i in range(7):
        A[i] = random.randint(0, 51)
    print(A)
    B = [[0 for col in range(2)] for row in range(7)]
    for i in range(7):
        B[i][0] = id2color(A[i])
        B[i][1] = id2num(A[i])

    B.sort(key=lambda f: f[1])
    # for i in B:
    #    print("color = %s, num = %s" % (i[0], i[1]))
    a = Hand(A)
    print(a.level)
    if a.level == 10:
        # print(A)
        for i in B:
            print("color = %s, num = %s" % (i[0], i[1]))
        # print(a.level)
        break
'''